<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Vocab Trainer â€” to be kobe (Offline .xlsx, Single HTML)</title>
  <style>
    :root{ --bd:#e5e7eb; --txt:#0f172a; --muted:#64748b; --bg:#ffffff; }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{margin:0;padding:0;background:linear-gradient(#fff,#f8fafc);color:var(--txt);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .container{max-width:760px;margin:0 auto;padding:12px 16px 96px}
    header{position:sticky;top:0;background:rgba(255,255,255,.8);backdrop-filter:blur(8px);border-bottom:1px solid var(--bd);z-index:10}
    header .row{display:flex;align-items:center;justify-content:space-between;gap:12px;max-width:760px;margin:0 auto;padding:10px 16px}
    h1{font-size:18px;margin:0}
    .badge{display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;border-radius:10px;color:#fff;background:linear-gradient(135deg,#6366f1,#06b6d4);box-shadow:0 1px 2px rgba(0,0,0,.06)}
    .card{background:#fff;border:1px solid var(--bd);border-radius:18px;box-shadow:0 1px 2px rgba(0,0,0,.04);padding:14px}
    .grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}

    /* Buttons */
    .btn{border:1px solid var(--bd);background:#fff;border-radius:14px;padding:10px 12px;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:8px;user-select:none;transition:transform .05s ease, box-shadow .2s ease}
    .btn:active{transform:scale(.985)}
    .btn.primary{background:#0f172a;color:#fff;border-color:#0f172a}
    .btn.wide{width:100%;padding:14px 16px;font-size:16px;border-radius:16px}
    .btn.grad{border:none;color:#fff;box-shadow:0 6px 14px rgba(0,0,0,.08), inset 0 1px rgba(255,255,255,.2)}
    .btn.grad.green{background:linear-gradient(135deg,#22c55e,#06b6d4)}
    .btn.grad.blue{background:linear-gradient(135deg,#3b82f6,#8b5cf6)}
    .btn.grad.orange{background:linear-gradient(135deg,#f59e0b,#ef4444)}
    .btn.ghost{background:#fff;border:1px solid var(--bd);}

    .muted{color:var(--muted);font-size:12px}
    .row{display:flex;align-items:center;justify-content:space-between}
    .gap{display:flex;gap:8px}
    .hidden{display:none}
    .bar{height:100px;display:flex;gap:8px;align-items:flex-end;justify-content:space-between}
    .bar>div{flex:1;background:#e2e8f0;border-radius:8px 8px 0 0}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid var(--bd);font-size:12px;background:#fff}
    .icon{width:20px;height:20px;border-radius:999px;display:inline-flex;align-items:center;justify-content:center;color:#fff}
    .i1{background:linear-gradient(135deg,#22c55e,#06b6d4)} .i2{background:linear-gradient(135deg,#3b82f6,#8b5cf6)} .i3{background:linear-gradient(135deg,#ef4444,#f97316)}

    /* Options: single line, bigger font, left-aligned */
    .opt{width:100%;display:flex;align-items:center;gap:10px;border:1px solid var(--bd);border-radius:14px;padding:12px;background:#fff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:left;justify-content:flex-start}
    .opt .badge{width:24px;height:24px;border-radius:999px;background:#fff;color:#0f172a;border:1px solid var(--bd);display:inline-flex;align-items:center;justify-content:center;font-weight:700;font-size:12px;box-shadow:none;flex:0 0 auto}
    .opt .text{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;font-size:16px;line-height:1.6}
    .opt.correct{background:#ecfdf5;border-color:#059669}
    .opt.wrong{background:#fef2f2;border-color:#dc2626}

    /* Reward animation */
    @keyframes pop{0%{transform:scale(.7);opacity:0}20%{transform:scale(1.1);opacity:1}80%{transform:scale(1);opacity:1}100%{transform:scale(.9);opacity:0}}
    .reward{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:50}
    .reward .text{font-size:34px;font-weight:800;animation:pop 1.1s ease-out forwards;background:linear-gradient(90deg,#ec4899,#f59e0b,#22c55e);-webkit-background-clip:text;background-clip:text;color:transparent;text-shadow:0 1px 2px rgba(0,0,0,.08)}
    @keyframes fall{0%{transform:translateY(-10px) rotate(0);opacity:1}100%{transform:translateY(110vh) rotate(720deg);opacity:0}}

    .fav { cursor:pointer; user-select:none; font-size:18px; }
    .fav.on { color:#f59e0b; text-shadow:0 1px 2px rgba(0,0,0,.08); }
    .toolbar { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; } /* Import åŒº */
  </style>
</head>
<body>
  <header>
    <div class="row">
      <div class="gap">
        <span class="badge">ğŸ“˜</span>
        <div>
          <h1>Vocab Trainer <span class="muted">â€” to be kobe</span></h1>
        </div>
      </div>
      <div class="muted" id="todayStat"></div>
    </div>
  </header>

  <div class="container">
    <!-- ç¾åŒ–åçš„ Import åŒº -->
    <section class="toolbar">
      <button class="btn grad green" id="btnImport">â¬†ï¸ Import</button>
      <input type="file" id="file" class="hidden" accept=".xlsx,.csv,.json" />
      <button class="btn grad blue" id="btnTemplate">ğŸ“¥ Template</button>
      <button class="btn grad orange" id="btnMode"><span>ğŸ”</span><span id="modeLabel">Mode: All</span></button>
    </section>

    <section class="grid-3" style="margin-top:8px">
      <button class="btn ghost" id="btnShuffle">ğŸ”€ Shuffle: OFF</button>
      <button class="btn ghost" id="btnAuto">âš™ï¸ Auto Next: OFF</button>
      <button class="btn ghost" id="btnReset">â™»ï¸ Reset</button>
    </section>

    <section style="margin-top:10px">
      <div class="card">
        <div class="row muted" style="margin-bottom:6px">
          <div id="qPos">Question 0/0</div>
          <div>Total: <span id="qTotal">0</span></div>
        </div>

        <div class="row" style="align-items:center; gap:8px;">
          <div id="qText" style="font-size:16px;font-weight:600;flex:1;min-height:40px">No questions yet. Click <b>Import</b> above.</div>
          <div id="favBtn" class="fav" title="Toggle favorite">â˜†</div>
        </div>

        <div id="opts" class="gap" style="flex-direction:column; margin-top:8px;"></div>

        <!-- æ–°å¢ï¼šNext æ”¾åœ¨é€‰é¡¹ä¸‹é¢çš„æ•´è¡Œå¤§æŒ‰é’®ï¼ˆç­”é¢˜åå‡ºç°ï¼‰ -->
        <div id="nextRow" class="hidden" style="margin-top:10px">
          <button class="btn primary wide" id="btnNext">Next âŸ¶</button>
        </div>

        <!-- ç»“æœä¸è§£é‡Š -->
        <div id="resultBox" class="hidden" style="margin-top:10px">
          <div id="resultText" class="pill">â€”</div>
          <div id="expBlock" class="card" style="margin-top:8px; padding:10px; border-radius:12px;">
            <div class="muted" style="margin-bottom:6px">Explanation</div>
            <div id="expText"></div>
          </div>
          <div class="gap" style="margin-top:8px">
            <button class="btn" id="btnPrev">âŸµ Prev</button>
            <button class="btn" id="btnRetry">Retry</button>
            <button class="btn" id="btnJump">ğŸ” Jump</button>
          </div>
        </div>
      </div>
    </section>

    <section style="margin-top:10px">
      <div class="card">
        <div class="gap" style="align-items:center;margin-bottom:6px">
          <span class="icon i2">ğŸ“Š</span><b>Last 7 Days</b>
        </div>
        <div id="bar" class="bar"></div>
      </div>
    </section>
  </div>

  <div id="reward" class="reward hidden">
    <div id="confetti"></div>
    <div class="text" id="rewardText">Excellent!</div>
  </div>

  <script>
    /************ Minimal ZIP + XLSX reader (no external deps) ************/
    const td = new TextDecoder("utf-8");
    function readU16(dv, off){ return dv.getUint16(off, true); }
    function readU32(dv, off){ return dv.getUint32(off, true); }
    function findEOCDR(bytes){ for (let i = bytes.length - 22; i >= 0 && i >= bytes.length - 65536 - 22; i--) {
        if (bytes[i]===0x50 && bytes[i+1]===0x4b && bytes[i+2]===0x05 && bytes[i+3]===0x06) return i; } return -1; }
    async function inflateRaw(u8){
      if (!('DecompressionStream' in self)) throw new Error("DecompressionStream not supported in this browser.");
      const ds = new DecompressionStream('deflate-raw');
      const stream = new Blob([u8]).stream().pipeThrough(ds);
      const ab = await new Response(stream).arrayBuffer();
      return new Uint8Array(ab);
    }
    async function unzip(bytes){
      const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      const eocdr = findEOCDR(bytes);
      if (eocdr < 0) throw new Error("Invalid ZIP: EOCDR not found.");
      const cdSize = readU32(dv, eocdr + 12);
      const cdOffset = readU32(dv, eocdr + 16);
      const files = {}; let p = cdOffset;
      while (p < cdOffset + cdSize){
        if (dv.getUint32(p, true) !== 0x02014b50) break;
        const compMethod = readU16(dv, p + 10);
        const compSize = readU32(dv, p + 20);
        const nameLen = readU16(dv, p + 28);
        const extraLen = readU16(dv, p + 30);
        const commentLen = readU16(dv, p + 32);
        const localHeaderRelOff = readU32(dv, p + 42);
        const name = td.decode(bytes.subarray(p + 46, p + 46 + nameLen));
        p += 46 + nameLen + extraLen + commentLen;
        let q = localHeaderRelOff;
        if (readU32(dv, q) !== 0x04034b50) throw new Error("Invalid ZIP: LFH missing.");
        const lfCompMethod = readU16(dv, q + 8);
        const lfNameLen = readU16(dv, q + 26);
        const lfExtraLen = readU16(dv, q + 28);
        const dataStart = q + 30 + lfNameLen + lfExtraLen;
        const comp = bytes.subarray(dataStart, dataStart + compSize);
        let content;
        if (compMethod === 0 || lfCompMethod === 0) content = comp;
        else if (compMethod === 8 || lfCompMethod === 8) content = await inflateRaw(comp);
        else throw new Error("Unsupported compression method: " + compMethod);
        files[name] = content;
      }
      return files;
    }
    function xml(str){ return new DOMParser().parseFromString(str, "application/xml"); }
    function sharedStringsFromXML(xmlDoc){
      const list = []; const si = Array.from(xmlDoc.getElementsByTagName("si"));
      si.forEach(node => { let text = ""; const tnodes = node.getElementsByTagName("t");
        for (let i=0;i<tnodes.length;i++){ text += tnodes[i].textContent || ""; } list.push(text); });
      return list;
    }
    function parseCellRef(ref){ let c=0,r=0,i=0; while (i<ref.length && /[A-Z]/i.test(ref[i])){ c=c*26+(ref[i].toUpperCase().charCodeAt(0)-64); i++; } r=parseInt(ref.slice(i),10); return {col:c,row:r}; }
    function sheetTo2DArray(xmlDoc, sst){
      const sheetData = xmlDoc.getElementsByTagName("sheetData")[0]; if (!sheetData) return [];
      const rows=[]; const rowNodes = Array.from(sheetData.getElementsByTagName("row"));
      rowNodes.forEach(rowNode => {
        const cells = Array.from(rowNode.getElementsByTagName("c")); if (cells.length===0) return;
        let maxCol=0; const temp={};
        cells.forEach(cn => { const r=cn.getAttribute("r")||""; const t=cn.getAttribute("t")||""; const { col } = parseCellRef(r); if (col>maxCol) maxCol=col;
          let val=""; const v=cn.getElementsByTagName("v")[0];
          if (t==="s"){ const idx=v?parseInt(v.textContent||"0",10):0; val=sst[idx]||""; }
          else if (t==="inlineStr"){ const is=cn.getElementsByTagName("is")[0]; const tn=is?is.getElementsByTagName("t")[0]:null; val=tn?tn.textContent||"":""; }
          else { val = v ? v.textContent || "" : ""; }
          temp[col]=val; });
        const arr=[]; for (let c=1;c<=maxCol;c++){ arr.push(temp[c]||""); } rows.push(arr);
      });
      return rows;
    }
    async function readXLSXToRows(file){
      const buf = new Uint8Array(await file.arrayBuffer());
      const files = await unzip(buf);
      const wbx = files["xl/workbook.xml"]; if (!wbx) throw new Error("workbook.xml not found");
      const wb = xml(td.decode(wbx));
      const sheets = wb.getElementsByTagName("sheet"); if (!sheets.length) throw new Error("no sheets");
      const firstSheet = sheets[0];
      const relId = firstSheet.getAttributeNS("http://schemas.openxmlformats.org/officeDocument/2006/relationships","id") || firstSheet.getAttribute("r:id");
      let sheetPath = "xl/worksheets/sheet1.xml";
      const relsBin = files["xl/_rels/workbook.xml.rels"];
      if (relsBin){ const rels = xml(td.decode(relsBin));
        const rs = Array.from(rels.getElementsByTagName("Relationship"));
        const found = rs.find(n => n.getAttribute("Id") === relId);
        if (found){ let target = found.getAttribute("Target") || "";
          if (target && !target.startsWith("xl/")) target = "xl/" + target.replace(/^\.\//,""); sheetPath = target; } }
      const sstBin = files["xl/sharedStrings.xml"]; const sst = sstBin ? sharedStringsFromXML(xml(td.decode(sstBin))) : [];
      const sheetBin = files[sheetPath]; if (!sheetBin) throw new Error("worksheet not found: " + sheetPath);
      const sheet = xml(td.decode(sheetBin)); const rows = sheetTo2DArray(sheet, sst); return rows;
    }

    /************ App state ************/
    const LS = { QUESTIONS:"vocab_questions_v1", WRONG:"vocab_wrong_v1", STATS:"vocab_stats_v1", SETTINGS:"vocab_settings_v1", FAV:"vocab_fav_v1" };
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const dayKey = (d=new Date()) => { const tz=d.getTimezoneOffset(); return new Date(d.getTime()-tz*60000).toISOString().slice(0,10); };
    const rewardWords = ["Excellent!","Outstanding!","Genius!","Brilliant!","Superb!","Spectacular!","Legendary!","Top-notch!","To be kobe!"];

    let settings = load(LS.SETTINGS, { shuffle:false, autoNext:false, mode:"all" });
    let questions = load(LS.QUESTIONS, []);
    let wrongSet = new Set(load(LS.WRONG, []));
    let favSet = new Set(load(LS.FAV, []));
    let stats = load(LS.STATS, {});

    // å›ºå®šä¼šè¯åºåˆ—ï¼ˆé˜² Shuffle ä¹±åºï¼‰ï¼Œåªåœ¨æ¨¡å¼/Shuffle åˆ‡æ¢æˆ–å¯¼å…¥æ—¶é‡å»º
    let session = { ids: [], cursor: 0 };
    let selected = null;
    let autoTimer = null;

    if (questions.length === 0) {
      questions = [
        { id:"1", q:"What is the meaning of 'meticulous'?", A:"careless", B:"careful and precise", C:"swift", D:"generous", answer:"B", explain:"Doing things with great attention to detail."},
        { id:"2", q:"Which word is closest in meaning to 'alleviate'?", A:"worsen", B:"ignore", C:"relieve", D:"describe", answer:"C", explain:"alleviate = make (suffering) less severe." },
      ];
      persist(LS.QUESTIONS, questions);
    }

    rebuildSession({ preserveCurrent:false });
    renderAll();

    /************ UI bindings ************/
    $("#btnImport").onclick = () => $("#file").click();
    $("#file").onchange = async (e) => {
      const f = e.target.files && e.target.files[0]; if (!f) return;
      try {
        let rows = [];
        if (f.name.toLowerCase().endsWith(".xlsx")) rows = await readXLSXToRows(f);
        else if (/\.(csv|txt)$/i.test(f.name)) rows = parseCSV(await f.text());
        else if (/\.(json)$/i.test(f.name)) {
          const arr = JSON.parse(await f.text()); const keys = Object.keys(arr[0] || {});
          rows = [keys, ...arr.map(o => keys.map(k => o[k] ?? ""))];
        } else { alert("Unsupported file format. Use .xlsx / .csv / .json"); return; }
        const mapped = normalizeQuestions(rows);
        if (!mapped.length) { alert("No valid rows found. Check header."); return; }
        questions = uniqueById(mapped); wrongSet = new Set(); favSet = new Set();
        persist(LS.QUESTIONS, questions); persist(LS.WRONG, Array.from(wrongSet)); persist(LS.FAV, Array.from(favSet));
        rebuildSession({ preserveCurrent:false }); selected = null; renderAll();
      } catch (err){ console.error(err); alert("Import failed: " + (err && err.message ? err.message : err)); }
      finally { e.target.value = ""; }
    };

    $("#btnTemplate").onclick = () => {
      const header = ["No.","Question","Option A","Option B","Option C","Option D","Answer","Explanation"];
      const row = [1,"What does 'benevolent' mean?","kind; charitable","warlike; belligerent","tedious; lengthy","cautious; careful","A","Root bene- means 'good'"];
      const csv = toCSV([header,row]); download(csv, "vocab-template.csv", "text/csv");
    };

    $("#btnMode").onclick = () => {
      settings.mode = settings.mode === "all" ? "wrong" : settings.mode === "wrong" ? "fav" : "all";
      persist(LS.SETTINGS, settings);
      rebuildSession({ preserveCurrent:false });
      renderAll();
    };

    $("#btnShuffle").onclick = () => {
      settings.shuffle = !settings.shuffle; persist(LS.SETTINGS, settings);
      rebuildSession({ preserveCurrent:false });
      renderAll();
    };

    $("#btnAuto").onclick = () => {
      settings.autoNext = !settings.autoNext; persist(LS.SETTINGS, settings); renderAll();
    };

    $("#btnReset").onclick = () => {
      if (!confirm("Clear all data (questions/wrong/fav/stats)?")) return;
      questions = []; wrongSet = new Set(); favSet = new Set(); stats = {};
      persist(LS.QUESTIONS, questions); persist(LS.WRONG, Array.from(wrongSet)); persist(LS.FAV, Array.from(favSet)); persist(LS.STATS, stats);
      rebuildSession({ preserveCurrent:false }); selected = null; renderAll();
    };

    // æŒ‰é’®ï¼šNext æ”¾åœ¨é€‰é¡¹ä¸‹æ–¹
    $("#btnNext").onclick = () => { next(); };
    $("#btnPrev").onclick = () => { prev(); };
    $("#btnRetry").onclick = () => { selected = null; renderQuestion(); };
    $("#btnJump").onclick = () => {
      if (!session.ids.length) return;
      const n = prompt(`Jump to which index? (1..${session.ids.length})`);
      const v = parseInt(n, 10);
      if (!isNaN(v) && v>=1 && v<=session.ids.length){
        session.cursor = v - 1; selected = null; renderQuestion();
      }
    };

    $("#favBtn").onclick = () => {
      const cur = currentQuestion();
      if (!cur) return;
      if (favSet.has(cur.id)) favSet.delete(cur.id); else favSet.add(cur.id);
      persist(LS.FAV, Array.from(favSet));
      updateFavUI();
    };

    /************ Session helpers ************/
    function computeModeIds(){
      if (settings.mode === "all") return questions.map(q=>q.id);
      if (settings.mode === "wrong") return questions.filter(q=>wrongSet.has(q.id)).map(q=>q.id);
      return questions.filter(q=>favSet.has(q.id)).map(q=>q.id); // fav
    }
    function shuffleInPlace(arr){ for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
    function rebuildSession({ preserveCurrent }){
      clearTimeout(autoTimer); autoTimer=null;
      const curId = currentQuestion()?.id || null;
      const ids = computeModeIds();
      if (settings.shuffle) shuffleInPlace(ids);
      session.ids = ids;
      if (preserveCurrent && curId){ const k = session.ids.indexOf(curId); session.cursor = k >=0 ? k : 0; }
      else session.cursor = 0;
    }
    function step(delta){
      if (!session.ids.length) return;
      let i = session.cursor;
      const total = session.ids.length;
      for (let attempt=0; attempt<total; attempt++){
        i = (i + delta + total) % total;
        const id = session.ids[i];
        if ((settings.mode==="all") ||
            (settings.mode==="wrong" && wrongSet.has(id)) ||
            (settings.mode==="fav" && favSet.has(id))){
          session.cursor = i; selected = null; renderQuestion(); return;
        }
      }
      rebuildSession({ preserveCurrent:false }); selected=null; renderQuestion();
    }
    function next(){ step(+1); }
    function prev(){ step(-1); }
    function currentQuestion(){
      if (!session.ids.length) return null;
      const id = session.ids[session.cursor];
      return questions.find(q => q.id === id) || null;
    }

    /************ Render ************/
    function renderAll(){
      renderHeader(); renderQuestion(); renderChart();
      $("#btnShuffle").innerHTML = settings.shuffle ? "ğŸ”€ Shuffle: ON" : "ğŸ”€ Shuffle: OFF";
      $("#btnAuto").innerHTML = settings.autoNext ? "âš™ï¸ Auto Next: ON" : "âš™ï¸ Auto Next: OFF";
      $("#modeLabel").textContent = "Mode: " + (settings.mode==="all"?"All":settings.mode==="wrong"?"Wrong":"Fav");
    }

    function renderHeader(){
      const k = keyToday(); const s = stats[k] || { ok:0, fail:0 };
      const total = s.ok + s.fail; const acc = total ? Math.round(s.ok/total*100) : 0;
      $("#todayStat").textContent = `Today: ${s.ok}âœ… / ${s.fail}âŒ Â· Acc ${acc}%`;
    }

    function renderQuestion(){
      const cur = currentQuestion();
      $("#qTotal").textContent = String(questions.length);
      $("#qPos").textContent = `Question ${session.ids.length ? (session.cursor+1) : 0}/${session.ids.length}`;
      const box = $("#opts"); box.innerHTML = "";
      $("#resultBox").classList.add("hidden");
      $("#expBlock").style.display = "none";
      $("#nextRow").classList.add("hidden");

      if (!cur){
        $("#qText").innerHTML = `No questions yet. Click <b>Import</b> above. <span class="muted">(Header: No., Question, Option A..D, Answer, Explanation)</span>`;
        $("#favBtn").classList.remove("on"); $("#favBtn").textContent = "â˜†";
        return;
      }
      $("#qText").textContent = cur.q;
      updateFavUI();

      ["A","B","C","D"].forEach(k=>{
        const label = cur[k] || ""; if (!label) return;
        const btn = document.createElement("button"); btn.className = "opt";
        btn.innerHTML = `<span class="badge">${k}</span><span class="text">${escapeHtml(label)}</span>`;
        btn.onclick = () => onSelect(k, btn); box.appendChild(btn);
      });
    }

    function updateFavUI(){
      const cur = currentQuestion();
      const el = $("#favBtn");
      if (!cur){ el.classList.remove("on"); el.textContent = "â˜†"; return; }
      if (favSet.has(cur.id)){ el.classList.add("on"); el.textContent = "â˜…"; } else { el.classList.remove("on"); el.textContent = "â˜†"; }
    }

    function onSelect(letter, el){
      const cur = currentQuestion(); if (!cur || selected) return;
      const correct = letter === cur.answer; selected = letter; updateToday(correct);
      if (correct){ el.classList.add("correct"); wrongSet.delete(cur.id); showReward(); }
      else { el.classList.add("wrong"); wrongSet.add(cur.id);
        $$("#opts .opt").forEach(n => { if (n.textContent.includes(cur.answer)) n.classList.add("correct"); });
      }
      persist(LS.WRONG, Array.from(wrongSet));

      // å±•ç¤ºâ€œNextâ€æ•´è¡ŒæŒ‰é’®ï¼ˆæ”¾åœ¨é€‰é¡¹ä¸‹æ–¹ï¼‰
      $("#nextRow").classList.remove("hidden");

      // å±•ç¤ºç»“æœä¸è§£é‡Šï¼ˆé»˜è®¤å±•å¼€ï¼‰
      $("#resultBox").classList.remove("hidden");
      $("#resultText").innerHTML = correct ? '<span class="pill" style="border-color:#10b981;color:#065f46">Correct!</span>' :
                                             `<span class="pill" style="border-color:#ef4444;color:#7f1d1d">Incorrect. Correct: ${cur.answer}</span>`;
      if (cur.explain){ $("#expText").textContent = cur.explain; $("#expBlock").style.display = "block"; }
      else { $("#expText").textContent = ""; $("#expBlock").style.display = "none"; }

      // Auto Nextï¼šä»…åœ¨é Shuffle ä¸‹å¯ç”¨ï¼›å¿«ç…§æ ¡éªŒ + é˜²æŠ–
      clearTimeout(autoTimer);
      if (settings.autoNext && !settings.shuffle && correct) {
        const snapCursor = session.cursor, snapId = cur.id;
        autoTimer = setTimeout(() => {
          if (session.cursor === snapCursor && currentQuestion()?.id === snapId) {
            next();
          }
        }, 3000); // 2s
      }
      renderHeader();
    }

    /************ Reward ************/
    function showReward(){
      const wrap = document.getElementById("reward");
      const label = document.getElementById("rewardText");
      label.textContent = rewardWords[Math.floor(Math.random()*rewardWords.length)];
      const conf = document.getElementById("confetti"); conf.innerHTML = "";
      const colors = ["#ef4444","#f59e0b","#10b981","#3b82f6","#8b5cf6","#ec4899","#22c55e","#06b6d4"];
      for (let i=0;i<26;i++){
        const span = document.createElement("span");
        span.style.position="absolute"; span.style.top="-10px";
        span.style.left=Math.round(Math.random()*100)+"%";
        const size = 6 + Math.round(Math.random()*6);
        span.style.width = size+"px"; span.style.height = size+"px";
        span.style.backgroundColor = colors[i%colors.length];
        span.style.opacity = .9;
        span.style.borderRadius = (i%3===0) ? "50%" : "2px";
        span.style.animation = `fall ${800+Math.round(Math.random()*900)}ms ease-out ${Math.round(Math.random()*150)}ms forwards`;
        conf.appendChild(span);
      }
      wrap.classList.remove("hidden");
      setTimeout(()=>wrap.classList.add("hidden"), 1100);
    }

    /************ Stats & Chart ************/
    function updateToday(ok){
      const k = keyToday(); const s = stats[k] || { ok:0, fail:0 }; if (ok) s.ok++; else s.fail++; stats[k] = s; persist(LS.STATS, stats);
    }
    function renderChart(){
      const el = document.getElementById("bar"); el.innerHTML = "";
      for (let i=6;i>=0;i--){
        const d = new Date(); d.setDate(d.getDate()-i);
        const k = dayKey(d); const s = stats[k] || { ok:0, fail:0 };
        const total = s.ok + s.fail; const ratio = total ? s.ok/total : 0;
        const h = Math.round(12 + ratio*80);
        const bar = document.createElement("div"); bar.style.height = h+"px";
        const info = document.createElement("div"); info.className = "muted"; info.style.textAlign="center"; info.style.fontSize="10px"; info.textContent = k.slice(5);
        const cell = document.createElement("div"); cell.style.display="flex"; cell.style.flexDirection="column"; cell.style.alignItems="center"; cell.style.gap="4px"; cell.style.flex="1";
        cell.appendChild(bar); cell.appendChild(info); el.appendChild(cell);
      }
    }

    /************ Utils ************/
    function uniqueById(arr){ const m = new Map(); arr.forEach(q=>{ if(!q.id) q.id = String(m.size+1); m.set(String(q.id), q); }); return Array.from(m.values()); }
    function keyToday(){ return dayKey(new Date()); }
    function load(key, def){ try{ const raw = localStorage.getItem(key); return raw?JSON.parse(raw):def; }catch{return def} }
    function persist(key,val){ localStorage.setItem(key, JSON.stringify(val)); }
    function parseCSV(text){
      const rows = []; let i=0, cur=[], field="", inQuotes=false;
      function endField(){ cur.push(field); field=""; }
      function endRow(){ rows.push(cur); cur=[]; }
      while(i<text.length){
        const c = text[i];
        if (inQuotes){
          if (c === '"'){ if (text[i+1] === '"'){ field+='"'; i++; } else { inQuotes=false; } }
          else { field+=c; }
        } else {
          if (c === '"'){ inQuotes=true; }
          else if (c === ','){ endField(); }
          else if (c === '\n'){ endField(); endRow(); }
          else if (c === '\r'){ }
          else { field+=c; }
        }
        i++;
      }
      endField(); endRow();
      return rows;
    }
    function toCSV(rows){
      return rows.map(r => r.map(x => {
        const s = String(x==null?"":x);
        return /[,\n"]/g.test(s) ? '"'+s.replace(/"/g,'""')+'"' : s;
      }).join(",")).join("\\n");
    }
    function normalizeQuestions(rows){
      if (!rows || !rows.length) return [];
      const header = rows[0].map(x => String(x||"").trim());
      const col = (name, aliases) => {
        const idx = header.findIndex(h => [name, ...aliases].map(a=>a.toLowerCase()).includes(h.toLowerCase()));
        return idx;
      };
      const map = {
        no: col("No.", ["åºå·","ç¼–å·","ID","id","no","NO"]),
        q: col("Question", ["é—®é¢˜","é¢˜å¹²"]),
        A: col("Option A", ["é€‰é¡¹A","A","a"]),
        B: col("Option B", ["é€‰é¡¹B","B","b"]),
        C: col("Option C", ["é€‰é¡¹C","C","c"]),
        D: col("Option D", ["é€‰é¡¹D","D","d"]),
        ans: col("Answer", ["ç­”æ¡ˆ","æ­£ç¡®ç­”æ¡ˆ","answer"]),
        exp: col("Explanation", ["è¯´æ˜","è§£æ","è§£é‡Š","å¤‡æ³¨"]),
      };
      const out = [];
      for (let r=1;r<rows.length;r++){
        const row = rows[r]; if (!row) continue;
        const id = (map.no>=0? row[map.no] : r) || r;
        const q = (map.q>=0? row[map.q] : "").toString().trim(); if (!q) continue;
        const A = ((map.A>=0? row[map.A] : "")||"").toString();
        const B = ((map.B>=0? row[map.B] : "")||"").toString();
        const C = ((map.C>=0? row[map.C] : "")||"").toString();
        const D = ((map.D>=0? row[map.D] : "")||"").toString();
        let ans = ((map.ans>=0? row[map.ans] : "")||"").toString().trim().toUpperCase();
        if (!["A","B","C","D"].includes(ans)){ if (ans.startsWith("A")) ans="A"; else if(ans.startsWith("B")) ans="B"; else if(ans.startsWith("C")) ans="C"; else if(ans.startsWith("D")) ans="D"; else ans=""; }
        const explain = ((map.exp>=0? row[map.exp] : "")||"").toString();
        if (!ans) continue;
        out.push({ id:String(id), q, A, B, C, D, answer:ans, explain });
      }
      return out;
    }
    function download(content, filename, type){
      const blob = new Blob([content], {type});
      const a = document.createElement("a"); a.href = URL.createObjectURL(blob);
      a.download = filename; a.click(); URL.revokeObjectURL(a.href);
    }
    function escapeHtml(s){ return s.replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;" }[c])); }
  </script>
</body>
</html>
